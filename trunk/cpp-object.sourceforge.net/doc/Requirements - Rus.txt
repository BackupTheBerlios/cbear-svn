Итак, что будет в библиотеке:
1. Возможность рефлексия для любого типа (требуется определение структуры типа).
2. Возможность использовать рефлексию как во времени компиляции, так и во времени выполнения.
3. Сериализация и десериализация за счет рефлексии.
4. Унифицированная передача аргументов.

Требования:
1. Минимум оверхеда.
2. При использовании рефлексии времени компиляции код должен приближаться к прямому обращению с объектом.

Примеры:

[b]1. Рефлексия:[/b]
[*] Во времени выполнения:
[c]
object o;
o.invoke("f", 1); // o.f(1);
[/c]
[*] Во времени компиляции:
[c]
object o;
o.invoke<f_tag>(1); // o.f(1);
[/c]
[*] object - Некий аналог boost::any с поддержкой рефлексии:
[c]
a x;
object o(x);

o.invoke<f_tag>(1); // x.f(1);

a z = object_cast<a>(o);
[/c]

[b]2. Унифицированная передача аргументов:[/b]
[*] in:
[c]
void f(in<int> x); // <=> void f(int x);
[/c]
[*] out:
[c]
void f(out<int> x); // <=> void f(int& x);
[/c]
[*] inout:
[c]
void f(inout<int> x); // <=> void f(int& x);
[/c]
[*] ref:
[c]
void f(out<int> x) // <=> void f(int& x);
{
 ref<int> y(x); // int& y(x);
}
[/c]
[*] cref:
[c]
void f(in<int> x) // <=> void f(int x);
{
 cref<int> y(x); // int const& y(x);
}
[/c]

[i]Код выше дан в качестве примера, это не окончательный код.[/i]